---
import "photoswipe/style.css";

import { getImage } from "astro:assets";

import type { EmblaOptionsType } from "embla-carousel";

import Controls, { type IndicatorType } from "./CarouselControls.astro";

interface Props {
  slideHeight?: string;
  images?: { src: string; alt: string }[];
  options?: EmblaOptionsType;
  indicatorType?: IndicatorType;
}

const { images = [], options, slideHeight, indicatorType } = Astro.props;
const optimizedImages = await Promise.all(
  images.map(async (image) => await getImage({ ...image, inferSize: true })),
);
---

<div class="embla" data-embla-options={JSON.stringify(options)}>
  <div class="embla__viewport">
    <div class="embla__container">
      {
        optimizedImages.map((image) => (
          <div class="embla__slide">
            <a
              data-pswp-src={image.src}
              data-pswp-width={image.options.width}
              data-pswp-height={image.options.height}
            >
              <img
                class="embla__slide__img"
                src={image.src}
                alt={image.attributes.alt}
              />
            </a>
          </div>
        ))
      }
    </div>
  </div>

  <Controls indicatorType={indicatorType} />
</div>

<style define:vars={{ slideHeight }}>
  .embla {
    padding-top: var(--flow-space);
    max-width: 48rem;
    margin: auto;
    --slide-height: var(--slideHeight);
    --slide-spacing: 1rem;
    --slide-size: 70%;
  }
  .embla__viewport {
    overflow: hidden;
  }
  .embla__container {
    display: flex;
    touch-action: pan-y pinch-zoom;
    margin-left: calc(var(--slide-spacing) * -1);
  }
  .embla__slide {
    flex: 0 0 var(--slide-size);
    min-width: 0;
    padding-left: var(--slide-spacing);
  }
  .embla__slide__img {
    display: block;
    height: var(--slide-height);
    width: 100%;
    object-fit: cover;
    border-radius: 8px;
  }
</style>

<script>
  import { object } from "astro:schema";

  import EmblaCarousel from "embla-carousel";
  import type { EmblaCarouselType, EmblaOptionsType } from "embla-carousel";
  import PhotoSwipeLightbox from "photoswipe/lightbox";

  import { addPrevNextButtonClickHandlers } from "./enable-arrow-buttons";
  import { addDotButtonAndClickHandlers } from "./enable-dot-buttons";
  import { updateSelectedSnapDisplay } from "./enable-snap-count";
  import { setupTweenOpacity } from "./tween-opacity";

  interface EmblaElement extends HTMLElement {
    __emblaApi?: EmblaCarouselType;
  }

  const initCarousel = (emblaNode: HTMLElement) => {
    const viewportNode = emblaNode.querySelector(
      ".embla__viewport",
    ) as HTMLElement;
    const prevBtn = emblaNode.querySelector(
      ".embla__button--prev",
    ) as HTMLElement;
    const nextBtn = emblaNode.querySelector(
      ".embla__button--next",
    ) as HTMLElement;
    const dotsNode = emblaNode.querySelector(".embla__dots") as HTMLElement;
    const displayNode = emblaNode.querySelector(
      ".embla__selected-snap-display",
    ) as HTMLElement;

    let options: EmblaOptionsType = { loop: true };

    try {
      const optionsFromAttribute = JSON.parse(
        emblaNode.dataset.emblaOptions || "{}",
      );
      if (Object.keys(optionsFromAttribute).length > 0)
        options = optionsFromAttribute;
    } catch {
      console.warn(
        "[EmblaCarousel]: Invalid options provided. Using default options.",
      );
    }

    let emblaApi = (emblaNode as EmblaElement).__emblaApi;
    if (!emblaApi) {
      emblaApi = EmblaCarousel(viewportNode, options);
      (emblaNode as EmblaElement).__emblaApi = emblaApi;
      addPrevNextButtonClickHandlers(emblaApi, prevBtn, nextBtn);

      if (dotsNode) {
        addDotButtonAndClickHandlers(emblaApi, dotsNode);
      }

      if (displayNode) {
        updateSelectedSnapDisplay(emblaApi, displayNode);
      }

      setupTweenOpacity(emblaApi);
    }

    return emblaApi;
  };

  const initPhotoswipe = () => {
    const lightbox = new PhotoSwipeLightbox({
      gallery: ".embla",
      children: ".embla__slide a",
      pswpModule: () => import("photoswipe"),
      bgClickAction: "close",
    });

    lightbox.addFilter("clickedIndex", (clickedIndex, e) => {
      const target = e.target as HTMLElement;
      const galleryEl = target.closest(".embla") as EmblaElement;
      const emblaApi = galleryEl?.__emblaApi;

      if (emblaApi) {
        const clickedSlide = target.closest(".embla__slide");
        const slides = Array.from(galleryEl.querySelectorAll(".embla__slide"));
        const actualIndex = slides.indexOf(clickedSlide!);

        const isSelected = actualIndex === emblaApi.selectedSnap();

        if (!isSelected) {
          return -1;
        }
      }

      return clickedIndex;
    });

    lightbox.init();
    lightbox.on("change", () => {
      const pwsp = lightbox.pswp;
      if (!pwsp) return;

      const index = pwsp.currIndex;
      const galleryEl = pwsp.currSlide?.data.element?.closest(".embla");
      if (!galleryEl) return;

      const emblaApi = (galleryEl as EmblaElement).__emblaApi;
      if (!emblaApi) return;

      pwsp.isOpen && emblaApi.goTo(index);
    });

    return lightbox;
  };

  document.addEventListener("astro:page-load", () => {
    const emblaNodes = document.querySelectorAll(".embla");
    emblaNodes.forEach((emblaNode) => {
      initCarousel(emblaNode as HTMLElement);
    });

    initPhotoswipe();
  });
</script>
